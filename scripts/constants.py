"""
NOTE:
for normal CORDIC:
* may save a clock cycle by starting the calculation at 45 degrees and manually checking if the angle is 0
"""

CORDIC_MODULE = """/**
 * @file cordic.sv
 * @author Geeoon Chung
 * @brief implements the cordic module
 * @see https://en.wikipedia.org/wiki/CORDIC
 * @note this file is autogenerated
 */

module cordic
    #(parameter BIT_WIDTH={}, 
      parameter LOG_2_BIT_WIDTH={},
      parameter K={})
    (clk, reset, start, angle, out_x, out_y, done);
    /**
     * @brief computes the coordinates of a rotation using CORDIC.  Only positive outputs (quadrant I)
     * @param   BIT_WIDTH=8 the width of the output data.
     *          Trigonometric output of 0 = 0
     *          Trigonometric output of 1 = 2^BIT_WIDTH - 1
     *		AND
     *          the width of the angle (scaled to the first quadrant).
     *          0 radians = 0
     *          pi / 4 radians = 2^(BIT_WIDTH-1)
     *          pi / 2 radians - 0 = 2^BIT_WIDTH - 1
     *          where "- 0" signifies a small value
     * @input   clk the clock driving the sequential logic
     * @input   reset an active high synchronous reset
     * @input	start 1 to start the calculation
     * @note    start will not do anything if done is 0
     * @input   angle the input angle.  width = DATA_WIDTH
     * @output  out_x the x coordinate output.  width = BIT_WIDTH
     * @output  out_y the y coordinate output.  width = BIT_WIDTH
     * @output  done 1 if the out_x and out_y registers can be read
     */
	input logic clk, reset, start;
	input logic [BIT_WIDTH-1:0] angle;

    output logic [BIT_WIDTH-1:0] out_x, out_y;
	output logic done;

    logic reached_target, dir, iter, load_regs, add, sub;
	cordiv_ctrl #(BIT_WIDTH=BIT_WIDTH) controller (.clk, .reset, .start, .reached_target, .dir, .iter, .load_regs, .add, .sub, .done)
	cordiv_data #(BIT_WIDTH=BIT_WIDTH, LOG_2_BIT_WIDTH=LOG_2_BIT_WIDTH, K=K) datapath (.clk, .add, .sub, .iter, .load_regs, .target(angle), .x(out_x), .y(out_y), .reached_target, .dir)

    
endmodule  // cordic
"""

CORDIC_CTRL_MODULE = """/**
 * @file cordic_ctrl.sv
 * @author Geeoon Chung
 * @brief implements the cordic_ctrl module, the controlpath for the cordic module
 */

module cordic_ctrl
    #(parameter BIT_WIDTH)
    (clk, reset, start, reached_target, dir, iter, load_regs, add, sub, done);
    /**
     * @brief datapath for the cordic module
     * @see ASMD chart
     * @note signals documented in the ASMD chart
     */
    input logic clk, reset, start, reached_target, dir;

    output logic iter, load_regs, add, sub, done;

    enum logic { s_init, s_compute } ps, ns;

    always_ff @(posedge clk) begin
        if (reset) ps <= s_init;
        else ps <= ns;
    end  // always_ff

    always_comb begin
        iter = 0;
        load_regs = 0;
        add = 0;
        sub = 0;
        done = 0;
        case (ps)
            s_init: begin
                done = 1;
                if (start): begin
                    load_regs = 1;
                    ns = s_compute;
                end else begin
                    ns = s_init;
                end
            end  // s_init

            s_compute: begin
                if (reached_target) begin
                    done = 1;  // saves a clock cycle
                    ns = s_init;
                end else begin
                    iter = 1;
                    if (dir) add = 1;
                    else sub = 1
                    ns = s_compute;
                end
            end  // s_compute
        endcase
    end  // always_comb

endmodule  // cordic_ctrl
"""

CORDIC_DATA_MODULE = """/**
 * @file cordic_rot.sv
 * @author Geeoon Chung
 * @brief implements the cordic_data module, the datapath for the cordic module
 */

module cordic_data
    #(parameter BIT_WIDTH,
      parameter LOG_2_BIT_WIDTH,
      parameter K)
    (clk, add, sub, iter, load_regs, target, x, y, reached_target, dir);
    /**
     * @brief controlpath for the cordic module
     * @see ASMD chart
     * @note signals documented in the ASMD chart
     */
    input logic clk, add, sub, iter, load_regs;
    input logic [BIT_WIDTH-1:0] target;

    output logic [BIT_WIDTH-1:0] x, y;
    output logic reached_target, dir; 

    logic [BIT_WIDTH-1:0] target_reg, current;
    logic [BIT_WIDTH-2:0] diff;
    logic [LOG_2_BIT_WIDTH-1:0] i;

    always_ff @(posedge clk) begin
        if (add) begin
            current <= current + diff;
            x <= x - (y >> i);
            y <= y - (x >> i);
        end

        if (sub) begin
            current <= current - diff;
            x <= x + (y >> i);
            y <= y - (x >> i);
        end

        if (iter) begin
            i <= i + 1;
            diff <= diff >> 1;
        end

        if (load_regs) begin
            diff <= '1;  // NOTE: might give truncation warning
            current <= 0;
            target_reg <= target;
            x <= K;
            y <= 0;
            i <= 1;
        end
    end  // always_ff

    always_comb begin
        reached_target = current == target;
        dir = current < target;
    end  // always_comb

endmodule  // cordic_data
"""